
# 一、KVector概述
KVector 是一个模板类，用于实现一个动态数组的功能。它封装了动态内存管理、元素插入、删除、访问等基本操作，并提供了一个迭代器接口以便遍历容器中的元素。
# 二、设计思路
## 2.1 动态内存管理
KVector底层实际上是管理一段连续的内存，通过数组实现。

* 封装了4个私有成员变量：  
`T* m_element` 指针指向动态分配的内存区域，用于存储向量中的元素。  
`m_capacity` 成员变量记录当前分配的容量，以便在需要时增加容量。  
`m_size`成员变量记录当前存储元素的个数。  
`m_alloc`是内存分配器，用户可以指定自定义的分配器，默认为`std::allocate`。  
* 提供 `reserve` 成员函数用于内部扩容，但不直接暴露给外部使用，以保持接口简洁。  
**注意**：这里区别`std::vector`,把容量预留函数私有化，内存不够时候，自动重新分配，用户仅仅在构造容器时可以指定容量大小！
* `autoShrinkCapacity`函数旨在自动调整容器的内部存储容量以提高内存使用效率。  
**实现思路**：当容器的当前容量（`m_capacity`）远大于其实际存储的元素数量（`m_size`）时，
具体来说，目前缩减策略由日常实验室开发得出的经验，本方法设置当容量是元素数量的四倍或更多时，该方法会触发一个缩容操作。在缩容过程中，首先计算一个新的容量，并使用提供的分配器来分配一块新的内存区域。随后，通过遍历当前存储的元素，并使用分配器的construct方法在新内存区域中构造每个元素的副本。原内存区域中的元素就会被逐个析构，以释放它们所占用的资源。最后，释放原内存区域，并更新容器的内部指针和容量以反映新的内存布局和容量大小。  
**优点**：通过`autoShrinkCapacity`方法，`KVecto`r能够在不牺牲太多性能的前提下，有效地减少其内存占用，这对于管理大量数据且元素数量频繁变化的场景特别有用然而，需要注意的是，频繁地调整容量可能会导致性能开销，因此在实际应用中应根据具体情况权衡是否启用此优化。  
**待优化**：后续可以想出更完美的容量缩减策略，例如可以让用户自定义比例，当`m_capacity/m_size`达到用户设定比例，自动缩减。

## 2.2 构造函数与析构函数
* 默认构造函数 `KVector()` 初始化一个空的向量，容量设置为0。
* 显式构造函数 `KVector(size_t s)` 允许用户指定初始容量，加入`explicit`声明，防止隐式转换。
* 析构函数 `~KVector()` 负责释放分配的内存资源，防止内存泄漏。
* 移动构造函数用于初始化一个`KVector`对象，通过“窃取”另一个`KVector`对象的资源（内存、大小、容量）来避免不必要的复制操作。这是通过直接交换资源指针和大小信息来实现的，而不是复制对象内容。移动后，源对象被置于一个安全但可识别的状态，通常是通过将其内部指针设为`nullptr`并重置大小为0来完成的，这样它就变成了空容器。  
**注意**：这里没有使用`delete[]`来释放`other.m_element`，因为移动操作后，这个内存的所有权已经转移给了新对象，`other`不再拥有它。
* 移动赋值运算符同样是为了避免不必要的复制操作。与移动构造函数类似，这也是通过直接交换资源指针和大小信息来实现的。移动后，源对象（`other`）同样被置于一个安全但可识别的空状态。首先检查自赋值（`this != &other`），这是防止将对象赋值给自己的重要步骤。
释放当前对象（`*this`）持有的资源。

## 2.3 移动语义
提供移动构造函数 `KVector(KVector&& other) noexcept` 和移动赋值运算符 `KVector& operator=(KVector&& other) noexcept`，
以支持高效的资源转移，避免不必要的拷贝操作。

## 2.4 元素操作
* `pushBack(const T& d)` 用于在向量末尾添加一个新元素，当插入元素时，容量空间不满足，通过调用私有函数`reserve`,自动以2倍内存扩容。扩容思路是先申请2倍的内存空间，将原来数组的元素一一拷贝，销毁源对象和内存空间。
* `getSize()` 返回当前向量中元素的数量（`m_size`）。
* `empty()` 检查向量是否为空，通过检查`m_size`是否为`0`实现。
* `clear()` 移除向量中的所有元素，但不释放内存（实际内存释放由析构函数或自动缩小容量时处理）。  
    ```C++
        void KVector<T, Allocator>::clear()
        {
            for (size_t i = 0; i < m_size; ++i) 
                m_alloc.destroy(m_element + i);
            m_size = 0;
        }
    ```
* `erase(size_t index)` 移除指定索引处的元素，并移动后续元素以填补空缺。删除当前元素后，后续的元素都需要移动地址空间向前补齐。
* `at(size_t index`) 和 `operator[](size_t index)` 提供按索引访问元素的功能，其中 at 方法在索引无效时会抛出异常，而 operator[] 不会。
* `insert(size_t index, const T& element)` 在指定索引处插入一个新元素，并移动后续元素以腾出空间，采用move移动元素，减少不必要的拷贝，提高性能。  

## 2.5 迭代器
`KVector<T>::KIterator`类的实现思路体现在其设计和功能上。这个类是为了提供一种机制，使得能够顺序地、安全地遍历KVector容器中的元素。  
**实现思路**：迭代器内部使用一个指向`T`类型元素的指针`m_cur`，该指针在迭代过程中表示当前迭代到的元素位置。
这个指针是迭代器的核心，因为它决定了迭代器在`KVector`容器中的“当前位置”。
通过重载`++`和`--`操作符，迭代器能够在遍历过程中向前或向后移动一个元素的位置。这些操作符通过调整`m_cur`指针的值来实现，确保迭代器能够顺序地访问容器中的每个元素。
重载`*`操作符允许用户通过迭代器直接访问当前位置所指向的元素。这是迭代器最重要的功能之一，因为它使得用户能够读取或修改容器中的元素值。
重载`==`和`!=`操作符使得两个迭代器之间可以进行比较，以判断它们是否指向同一个位置或不同的位置。这对于循环遍历容器时确定何时停止迭代非常有用。  

## 2.6 异常安全性
* `noexcept`作用：
在C++中，`noexcept`关键字用于指明某个函数不会抛出异常。当你在函数声明或定义后加上`noexcept`时，告诉编译器和调用者这个函数保证不会抛出异常。

* `reserve`函数中设置异常处理：
在`reserve`中，使用了`try-catch`块来捕获并处理`std::bad_alloc`异常。如果`allocate`调用失败，
则捕获该异常，并可以选择性地处理它。
```C++
	try 
	{
		T* newElements = m_alloc.allocate(newCapacity);
		if (m_size > 0) 
		{
			for (size_t i = 0; i < m_size; ++i)
				m_alloc.construct(newElements + i, std::move(m_element[i]));
			// 销毁旧数组中的元素  
			for (size_t i = 0; i < m_size; ++i)
				m_alloc.destroy(m_element + i);
			// 释放旧数组的内存  
			m_alloc.deallocate(m_element, m_capacity);
		}
		// 更新成员变量  
		m_element = newElements;
		m_capacity = newCapacity;
	}
	catch (const std::bad_alloc& e) 
	{
		std::cerr << "Memory allocation failed: " << e.what() << std::endl;
		throw; // 重新抛出捕获的异常，让调用者知道发生了什么  
	}
```

## 2.7 用户自定义内存分配器（`kallocator.h`文件）
`KAllocator`类是一个自定义的内存分配器模板，用于为给定类型`T`的对象分配和释放内存，并提供了在已分配的内存上构造和析构对象。
* 类型定义：  
`pointer`：定义了一个指向类型`T`的指针类型，用于在分配器中引用内存地址。
`size_type`：定义了用于表示大小的类型，这里直接使用`size_t`，用于表示对象大小或内存量。
* 成员函数：  
`allocate(size_type n)`：此函数用于分配n个T类型对象所需的内存。它通过调用全局的`operator new`来完成，并将分配的内存量计算为`n * sizeof(T)`。分配成功后，它返回指向这块内存的指针（已转换为`pointer`类型）。  
`deallocate(pointer p, size_type n)`：此函数用于释放之前通过`allocate`函数分配的内存。它接收两个参数：一个是指向要释放内存的指针`p`，另一个是原始分配的对象数量`n`。它通过调用全局的`operator delete`来释放内存。  
`construct(pointer p, const T& value)`：此函数在已分配的内存上构造一个`T`类型的对象。它使用`placement new`语法（`new (p) T(value)`）在指定位置`p`上构造一个`T`类型的对象，该对象被初始化为`value`的副本。  
`destroy(pointer p)`：此函数析构位于指定位置p的T类型对象。它直接调用对象的析构函数（`p->~T()`）来释放对象占用的资源，但不释放对象本身所占用的内存。这块内存的释放应该通过调用deallocate函数来完成。

# 三、性能优化
## 3.1 inline函数的使用
* 目的：
inline函数的主要目的是减少函数调用的开销，通过将函数体直接嵌入到调用点来提高程序的执行效率。
它适用于体积小、调用频繁且不会造成代码膨胀的函数。

* 应用实例：
在`KVector<T>`中，可以将访问器（如`at()`, `operator[]`）等小型且频繁调用的成员函数声明为inline。
inline只是向编译器发出一个请求，编译器有权忽略这个请求，特别是当函数体过大或包含复杂的控制结构时。

## 3.2 std::move的使用
* 目的：
在插入和删除元素时，使用`std::move`可以将元素的移动操作优化为浅拷贝，减少不必要的拷贝开销，特别是在处理大型对象或资源密集型对象时。

* 应用实例：
在`KVector<T>`的`insert`和`erase`函数中，当需要移动元素以维持容器的连续性时，可以使用`std::move`来优化这一过程。
例如，在`insert`操作中，当插入某个元素后，需要将后续元素向后移动。此时，可以使用`std::move`来避免不必要的深拷贝：
```C++
	for (size_t i = m_size; i > index; --i)
		m_element[i] = std::move(m_element[i - 1]);
```  
# 四、遇到困难与解决方案

## 4.1 默认构造函数时候，使用pushBack内存越界问题
当使用默认构造函数初始化容器，容器未分配内存，容量为0，这时使用`pushBack`会发送错误。  
解决方案：在`pushBack`函数加入容量判断
```C++
	if (m_capacity == 0) 
		{
			reserve(8);//如果0，初始化为8
		}
```

## 4.2 移动拷贝构造函数
问题：在实现移动拷贝构造函数时候，删除了原数组，发生错误。  
解决：涉及到`move`移动语义的深刻理解，我们只是把原始数据的所有权转移给新的对象了。注释掉删除数组操作！
```C++
	template<typename T>
	KVector<T>::KVector(KVector &&other) noexcept
		: m_size(other.m_size)
		, m_element(other.m_element)
		, m_capacity(other.m_capacity)
	{
		//delete[] other.m_element;
		other.m_element = nullptr;
		other.m_capacity = 0;
		other.m_size = 0;
	}
```

## 4.3 用户自定义内存分配器
困难：对内存分配了解较少，初期实现的时候有一定困难。  
解决方案：
* 学习`std::allocator`,了解相关接口，自定义分配器需要定义一系列接口（如 `allocate、deallocate、construct、destroy` 等），
这些接口需要与容器的要求相匹配。
* 学习网络开源资料，借鉴他人自定义内存分配器的实现思路。定义了4个常用接口，重写`KVector`中与内存分配相关代码（第一版代码未考虑内存分配器，直接使用的数组实现）。
* 和小组成员交流，学习他们的实现方式，利用模板让用户可以自定义内存分配器，`KVector`默认使用`std::allocator`。

# 五、未来优化与扩展
* 目前迭代器仅仅用来遍历元素，未来可以实现更复杂的迭代器类型，并且可以通过迭代器修改元素等操作。
* 用户自定义内存分配器，目前时间原因，仅仅写了内存分配与销毁和对象构建与销毁，未来计划可以实现更丰富的功能，区分std内置分配。
* 进一步优化内存管理策略，如采用更智能的扩容和缩容策略，以平衡内存使用效率和性能。
