# -demo-

1.项目1：利用深度学习算法检测与识别物体
项目要求：自动识别出灭火器三个挡位状态（合格/不合格），达到自动判别效果，减少人力。
项目使用硬件：树莓派4B 4G ，OV5647模组（500W像素），华硕笔记本。
准备数据：3中类别数据各3000张。（强光，昏暗，灰尘遮挡等多种复杂情况）
项目算法：YOLOV5-s版本，输入图像640*640。测试集识别准确率达到96%以上。
项目具有保密性，仅展示YOLOV5-LITE版本在树莓派部署情况。
https://github.com/chaoyangxiao/-demo-/assets/111733805/92671a2a-f201-428d-94e0-f786649352a8



# 一、KVector概述
KVector 是一个模板类，用于实现一个动态数组的功能。它封装了动态内存管理、元素插入、删除、访问等基本操作，
并提供了一个迭代器接口以便遍历容器中的元素。该类的设计旨在提供一个高效、易用且灵活的动态数组实现。

# 二、设计思路
## 2.1 动态内存管理
KVector底层实际上是管理一段连续的内存，通过数组实现。
使用 T* m_element 指针指向动态分配的内存区域，用于存储向量中的元素。
通过 m_capacity 成员变量记录当前分配的容量，以便在需要时增加容量。
* 提供 reserve 成员函数用于内部扩容，但不直接暴露给外部使用，以保持接口简洁。
注意：这里区别std::vector,把容量预留函数私有化，内存不够时候，自动重新分配，用户仅仅在构造容器时可以指定容量大小！
* autoShrinkCapacity函数旨在自动调整容器的内部存储容量以提高内存使用效率。当容器的当前容量（m_capacity）远大于其实际存储的元素数量（m_size）时，
具体来说，目前缩减策略由日常实验室开发得出的经验（后续可以想出更完美的容量缩减策略，
例如可以让用户自定义比例，当m_capacity/m_size达到用户设定比例，自动缩减）。本方法设置当容量是元素数量的四倍或更多时，该方法会触发一个缩容操作。
在缩容过程中，首先计算一个新的、更小的容量（这里选择将当前容量减半），并使用提供的分配器（Allocator）来分配一块新的内存区域（newElements）。随后，通过遍历当前存储的元素，并使用分配器的construct方法在新内存区域中构造每个元素的副本（这里采用std::move以支持移动语义，尽可能减少不必要的复制开销）。一旦所有元素都被成功移动并构造到新位置，原内存区域中的元素就会被逐个析构（通过分配器的destroy方法），
以释放它们所占用的资源。最后，释放原内存区域，并更新容器的内部指针（m_element）和容量（m_capacity）以反映新的内存布局和容量大小。
通过autoShrinkCapacity方法，KVector能够在不牺牲太多性能的前提下，有效地减少其内存占用，这对于管理大量数据且元素数量频繁变化的场景特别有用。
然而，需要注意的是，频繁地调整容量可能会导致性能开销，因此在实际应用中应根据具体情况权衡是否启用此优化。

## 2.2 构造函数与析构函数
* 默认构造函数 KVector() 初始化一个空的向量。
* 显式构造函数 KVector(size_t s) 允许用户指定初始容量。
* 析构函数 ~KVector() 负责释放分配的内存资源，防止内存泄漏。
* 移动构造函数用于初始化一个KVector对象，通过“窃取”另一个KVector对象（other）的资源（内存、大小、容量）来避免不必要的复制操作。这是通过直接交换资源指针和大小信息来实现的，而不是复制对象内容。
移动后，源对象（other）被置于一个安全但可识别的状态，通常是通过将其内部指针设为nullptr并重置大小为0来完成的，这样它就变成了空容器。
直接从other中获取m_size、m_element和m_capacity的值。将other的m_element指针设为nullptr，m_size和m_capacity设为0，以确保other对象在移动后处于安全状态。
注意：这里没有使用delete[]来释放other.m_element，因为移动操作后，这个内存的所有权已经转移给了新对象，other不再拥有它。
* 移动赋值运算符同样是为了避免不必要的复制操作。与移动构造函数类似，这也是通过直接交换资源指针和大小信息来实现的。
移动后，源对象（other）同样被置于一个安全但可识别的空状态。首先检查自赋值（this != &other），这是防止将对象赋值给自己的重要步骤。
释放当前对象（*this）持有的资源。从other中获取m_size、m_element和m_capacity的值，并将它们赋给当前对象。
将other的m_element指针设为nullptr，m_size和m_capacity设为0，以确保other对象在移动后处于安全状态。

## 2.3 移动语义
提供移动构造函数 KVector(KVector&& other) noexcept 和移动赋值运算符 KVector& operator=(KVector&& other) noexcept，
以支持高效的资源转移，避免不必要的拷贝操作。

## 2.4 元素操作
* pushBack(const T& d) 用于在向量末尾添加一个新元素，当插入元素时，容量空间不满足，自动以2倍内存扩容。
扩容思路是先申请2倍的内存空间，将原来数组的元素一一拷贝，销毁源对象和内存空间。
* getSize() 返回当前向量中元素的数量（m_size）。
* empty() 检查向量是否为空，通过检查m_size是否为0实现。
* clear() 移除向量中的所有元素，但不释放内存（实际内存释放由析构函数或自动缩小容量时处理）。
* erase(size_t index) 移除指定索引处的元素，并移动后续元素以填补空缺。删除当前元素后，后续的元素都需要移动地址空间向前补齐。
* at(size_t index) 和 operator[](size_t index) 提供按索引访问元素的功能，其中 at 方法在索引无效时会抛出异常，而 operator[] 不会。
* insert(size_t index, const T& element) 在指定索引处插入一个新元素，并移动后续元素以腾出空间。

## 2.5 迭代器
KVector<T>::KIterator类的实现思路体现在其设计和功能上。这个类是为了提供一种机制，使得能够顺序地、安全地遍历KVector容器中的元素。
具体来说，迭代器内部使用一个指向T类型元素的指针m_cur，该指针在迭代过程中表示当前迭代到的元素位置。
这个指针是迭代器的核心，因为它决定了迭代器在KVector容器中的“当前位置”。
通过重载++和--操作符，迭代器能够在遍历过程中向前或向后移动一个元素的位置。这些操作符通过调整m_cur指针的值来实现，确保迭代器能够顺序地访问容器中的每个元素。
重载*操作符允许用户通过迭代器直接访问当前位置所指向的元素。这是迭代器最重要的功能之一，因为它使得用户能够读取或修改容器中的元素值。
重载==和!=操作符使得两个迭代器之间可以进行比较，以判断它们是否指向同一个位置或不同的位置。这对于循环遍历容器时确定何时停止迭代非常有用。

## 2.6 异常安全性
* noexcept作用：
在C++中，noexcept关键字用于指明某个函数不会抛出异常。当你在函数声明或定义后加上noexcept时，告诉编译器和调用者这个函数保证不会抛出异常。

* reserve函数中设置异常处理：
在reserve中，使用了try-catch块来捕获并处理std::bad_alloc异常。如果allocate调用失败，
则捕获该异常，并可以选择性地处理它。在这个函数中，我使用了try-catch块来捕获并处理std::bad_alloc异常。
如果allocate调用失败，则捕获该异常，并可以选择性地处理它（例如，通过打印错误消息并重新抛出异常）。

## 2.7 用户自定义内存分配器（kallocator.h文件）
KAllocator类是一个自定义的内存分配器模板，用于为给定类型T的对象分配和释放内存，并提供了在已分配的内存上构造和析构对象。
* 类型定义：
pointer：定义了一个指向类型T的指针类型，用于在分配器中引用内存地址。
size_type：定义了用于表示大小的类型，这里直接使用size_t，用于表示对象大小或内存量。
* 成员函数：
allocate(size_type n)：此函数用于分配n个T类型对象所需的内存。它通过调用全局的operator new来完成，并将分配的内存量计算为n * sizeof(T)。分配成功后，它返回指向这块内存的指针（已转换为pointer类型）。
deallocate(pointer p, size_type n)：此函数用于释放之前通过allocate函数分配的内存。它接收两个参数：一个是指向要释放内存的指针p，
另一个是原始分配的对象数量n。它通过调用全局的operator delete来释放内存。
construct(pointer p, const T& value)：此函数在已分配的内存上构造一个T类型的对象。它使用placement new语法（new (p) T(value)）在指定位置p上构造一个T类型的对象，该对象被初始化为value的副本。
destroy(pointer p)：此函数析构位于指定位置p的T类型对象。它直接调用对象的析构函数（p->~T()）来释放对象占用的资源，但不释放对象本身所占用的内存。这块内存的释放应该通过调用deallocate函数来完成。

# 三、性能优化
## 3.1 inline函数的使用
* 目的：
inline函数的主要目的是减少函数调用的开销，通过将函数体直接嵌入到调用点来提高程序的执行效率。
它适用于体积小、调用频繁且不会造成代码膨胀的函数。

* 应用实例：
在KVector<T>中，可以将访问器（如at(), operator[]）等小型且频繁调用的成员函数声明为inline。
inline只是向编译器发出一个请求，编译器有权忽略这个请求，特别是当函数体过大或包含复杂的控制结构时。

## 3.2 std::move的使用
* 目的：
在插入和删除元素时，使用std::move可以将元素的移动操作优化为浅拷贝，减少不必要的拷贝开销，特别是在处理大型对象或资源密集型对象时。

* 应用实例：
在KVector<T>的insert和erase函数中，当需要移动元素以维持容器的连续性时，可以使用std::move来优化这一过程。
例如，在insert操作中，当插入某个元素后，需要将后续元素向后移动。此时，可以使用std::move来避免不必要的深拷贝：
```
	for (size_t i = m_size; i > index; --i)
		m_element[i] = std::move(m_element[i - 1]);
```

# 四、遇到困难与解决方案

## 4.1 默认构造函数时候，使用pushBack内存越界问题
当使用默认构造函数初始化容器，容器未分配内存，容量为0，这时使用pushBack会发送错误。
解决方案：在pushBack函数加入容量判断
```
	if (m_capacity == 0) 
		{
			reserve(8);//如果0，初始化为8
		}
```

## 4.2 移动拷贝构造函数
问题：在实现移动拷贝构造函数时候，删除了原数组，发生错误。
解决：涉及到move移动语义的深刻理解，我们只是把原始数据的所有权转移给新的对象了。注释掉删除数组操作！
```
	template<typename T>
	KVector<T>::KVector(KVector &&other) noexcept
		: m_size(other.m_size)
		, m_element(other.m_element)
		, m_capacity(other.m_capacity)
	{
		//delete[] other.m_element;
		other.m_element = nullptr;
		other.m_capacity = 0;
		other.m_size = 0;
	}
```

## 4.3 用户自定义内存分配器
困难：对内存分配了解较少，初期实现的时候有一定困难。  
解决方案：
* 学习std::allocator,了解相关接口，自定义分配器需要定义一系列接口（如 allocate、deallocate、construct、destroy 等），
这些接口需要与容器的要求相匹配。
* 学习网络开源资料，借鉴他人自定义内存分配器的实现思路。定义了4个常用接口，重写KVector中与内存分配相关代码
（第一版代码未考虑内存分配器，直接使用的数组实现）。
* 和小组成员交流，学习他们的实现方式，利用模板让用户可以自定义内存分配器，KVector默认使用std::allocator。

# 五、未来优化与扩展
* 目前迭代器仅仅用来遍历元素，未来可以实现更复杂的迭代器类型，并且可以通过迭代器修改元素等操作。
* 用户自定义内存分配器，目前时间原因，仅仅写了内存分配与销毁和对象构建与销毁，未来计划可以实现更丰富的功能，区分std内置分配。
* 进一步优化内存管理策略，如采用更智能的扩容和缩容策略，以平衡内存使用效率和性能。
