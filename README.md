# -demo-

1.项目1：利用深度学习算法检测与识别物体
项目要求：自动识别出灭火器三个挡位状态（合格/不合格），达到自动判别效果，减少人力。
项目使用硬件：树莓派4B 4G ，OV5647模组（500W像素），华硕笔记本。
准备数据：3中类别数据各3000张。（强光，昏暗，灰尘遮挡等多种复杂情况）
项目算法：YOLOV5-s版本，输入图像640*640。测试集识别准确率达到96%以上。
项目具有保密性，仅展示YOLOV5-LITE版本在树莓派部署情况。
https://github.com/chaoyangxiao/-demo-/assets/111733805/92671a2a-f201-428d-94e0-f786649352a8


# 一、KVector概述
KVector 是一个模板类，用于实现一个动态数组的功能。它封装了动态内存管理、元素插入、删除、访问等基本操作，
并提供了一个迭代器接口以便遍历容器中的元素。该类的设计旨在提供一个高效、易用且灵活的动态数组实现。

# 二、设计思路
## 2.1 动态内存管理：
KVector底层实际上是管理一段连续的内存，通过数组实现。
使用 T* m_element 指针指向动态分配的内存区域，用于存储向量中的元素。
通过 m_capacity 成员变量记录当前分配的容量，以便在需要时增加容量。
提供 reserve 成员函数用于内部扩容，但不直接暴露给外部使用，以保持接口简洁。
当元素数量减少到一定程度时，通过 autoShrinkCapacity 自动减小容量以节省内存空间。
## 2.2 构造函数与析构函数：
默认构造函数 KVector() 初始化一个空的向量。
显式构造函数 KVector(size_t s) 允许用户指定初始容量。
析构函数 ~KVector() 负责释放分配的内存资源，防止内存泄漏。
## 2.3 移动语义：
提供移动构造函数 KVector(KVector&& other) noexcept 和移动赋值运算符 KVector& operator=(KVector&& other) noexcept，
以支持高效的资源转移，避免不必要的拷贝操作。
## 2.4 元素操作：
pushBack(const T& d) 用于在向量末尾添加一个新元素，当插入元素时，容量空间不满足，自动以2倍内存扩容。
getSize() 返回当前向量中元素的数量。
empty() 检查向量是否为空。
clear() 移除向量中的所有元素，但不释放内存（实际内存释放由析构函数或自动缩小容量时处理）。
erase(size_t index) 移除指定索引处的元素，并移动后续元素以填补空缺。
at(size_t index) 和 operator[](size_t index) 提供按索引访问元素的功能，其中 at 方法在索引无效时会抛出异常，而 operator[] 不会。
insert(size_t index, const T& element) 在指定索引处插入一个新元素，并移动后续元素以腾出空间。
## 2.5 迭代器：
KVector<T>::KIterator类的实现思路体现在其设计和功能上。这个类是为了提供一种机制，使得能够顺序地、安全地遍历KVector容器中的元素。
具体来说，迭代器内部使用一个指向T类型元素的指针m_cur，该指针在迭代过程中表示当前迭代到的元素位置。
这个指针是迭代器的核心，因为它决定了迭代器在KVector容器中的“当前位置”。
通过重载++和--操作符，迭代器能够在遍历过程中向前或向后移动一个元素的位置。这些操作符通过调整m_cur指针的值来实现，确保迭代器能够顺序地访问容器中的每个元素。
重载*操作符允许用户通过迭代器直接访问当前位置所指向的元素。这是迭代器最重要的功能之一，因为它使得用户能够读取或修改容器中的元素值。
重载==和!=操作符使得两个迭代器之间可以进行比较，以判断它们是否指向同一个位置或不同的位置。这对于循环遍历容器时确定何时停止迭代非常有用。
## 2.6 异常安全性：
noexcept作用：
在C++中，noexcept关键字用于指明某个函数不会抛出异常。当你在函数声明或定义后加上noexcept时，告诉编译器和调用者这个函数保证不会抛出异常。

reserve分配保证处理异常：
它使用new (std::nothrow)来分配内存，这样如果内存分配失败，newData将被设置为nullptr，而不是抛出一个异常。然后，resize函数检查newData是否为nullptr，如果是，则抛出一个std::bad_alloc异常。这样，调用者就可以捕获这个异常并相应地处理它。
另外，pushBack函数在调用resize之后，再将新元素添加到容器的末尾，并更新容器的大小。如果在resize过程中发生异常，pushBack函数将不会修改容器的状态，从而保持容器的一致性。
需要注意的是，在实际应用中，你可能还需要考虑其他异常安全性问题，比如在元素复制或移动过程中可能发生的异常。这通常涉及到使用更复杂的异常处理技术，如“提交或回滚”语义，以确保在发生异常时容器能够恢复到一致的状态。

# 三、性能优化
## 3.1 inline函数的使用
*目的*：
inline函数的主要目的是减少函数调用的开销，通过将函数体直接嵌入到调用点来提高程序的执行效率。
它适用于体积小、调用频繁且不会造成代码膨胀的函数。
*应用实例*：
在KVector<T>中，可以将访问器（如at(), operator[]）等小型且频繁调用的成员函数声明为inline。
inline只是向编译器发出一个请求，编译器有权忽略这个请求，特别是当函数体过大或包含复杂的控制结构时。
## 3.2 std::move的使用
*目的*：
在插入和删除元素时，使用std::move可以将元素的移动操作优化为浅拷贝，减少不必要的拷贝开销，特别是在处理大型对象或资源密集型对象时。
*应用实例*：
在KVector<T>的insert和erase函数中，当需要移动元素以维持容器的连续性时，可以使用std::move来优化这一过程。
例如，在insert操作中，当插入某个元素后，需要将后续元素向后移动。此时，可以使用std::move来避免不必要的深拷贝：
'''
	for (size_t i = m_size; i > index; --i)
		m_element[i] = std::move(m_element[i - 1]);
'''
# 四、遇到困难与解决方案
## 4.1 pushBack内存越界问题
当使用默认构造函数初始化容器，容器未分配内存，这时使用pushBack会发送错误。
解决方案：在pushBack函数加入容量判断
'''
	if (m_capacity == 0) 
		{
			reserve(8);//如果0，初始化为8
		}
'''
## 4.2 移动拷贝构造函数
问题：在实现移动拷贝构造函数时候，删除了原数组，发生错误。
解决：涉及到move移动语义的深刻理解，我们只是把原始数据的所有权转移给新的对象了。注释掉删除数组操作！
'''
	template<typename T>
	KVector<T>::KVector(KVector &&other) noexcept
		: m_size(other.m_size)
		, m_element(other.m_element)
		, m_capacity(other.m_capacity)
	{
		//delete[] other.m_element;
		other.m_element = nullptr;
		other.m_capacity = 0;
		other.m_size = 0;
	}
'''

# 五、未来优化与扩展
* 可以考虑添加异常安全保证，确保在元素操作（如插入、删除）过程中遇到异常时，向量状态能够恢复到操作前的状态。
* 实现更复杂的迭代器类型，如反向迭代器，以支持反向遍历向量。
* 进一步优化内存管理策略，如采用更智能的扩容和缩容策略，以平衡内存使用效率和性能。
